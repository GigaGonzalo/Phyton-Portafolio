ğŸ Â¡PROGRAMACIÃ“N ORIENTADA A OBJETOS PYTHON-O-MATIC! ğŸ

Â¡LLEGÃ“ LA REVOLUCIÃ“N EN ORGANIZACIÃ“N Y REUTILIZACIÃ“N DE CÃ“DIGO!
ğŸ¯ Â¡POO EN PYTHON - PODER DE ORGANIZACIÃ“N EXTREMA!
python

# âš¡ Â¡BIENVENIDO AL MUNDO DE LA POO! âš¡
print("ğŸŠ Â¡POO PYTHON - ORGANIZA COMO UN ARQUITECTO! ğŸŠ")
print("Â¿Cansado de cÃ³digo desorganizado? Â¿Confundido con datos dispersos?")
print("Â¡LA POO lo estructura TODO! ğŸ’«")

ğŸš€ Â¡CLASES Y OBJETOS - LOS CIMIENTOS DE LA POO!
âœ¨ CLASE BÃSICA - Â¡TU PRIMER MOLDE!


# Â¡DEFINIENDO TU PRIMERA CLASE!
class Perro:
    """Clase que representa a un perro - Â¡Tu primer molde!"""
    
    # Â¡ATRIBUTO DE CLASE - Compartido por todos!
    especie = "Canis lupus familiaris"
    
    def __init__(self, nombre, edad, raza):
        """MÃ©todo constructor - Â¡Inicializa el objeto!"""
        # Â¡ATRIBUTOS DE INSTANCIA - Ãšnicos para cada objeto!
        self.nombre = nombre
        self.edad = edad
        self.raza = raza
        self.energia = 100
        print(f"ğŸ• Â¡Nuevo perro creado: {self.nombre}!")
    
    def ladrar(self):
        """MÃ©todo - Â¡AcciÃ³n que puede realizar el objeto!"""
        return f"Â¡{self.nombre} dice: Guau Guau! ğŸ¾"
    
    def comer(self, comida):
        """MÃ©todo con parÃ¡metros"""
        self.energia += 20
        return f"ğŸ– {self.nombre} estÃ¡ comiendo {comida}. EnergÃ­a: {self.energia}"
    
    def correr(self, distancia):
        """MÃ©todo que modifica estado interno"""
        if self.energia >= distancia * 5:
            self.energia -= distancia * 5
            return f"ğŸƒ {self.nombre} corriÃ³ {distancia} km. EnergÃ­a restante: {self.energia}"
        else:
            return f"ğŸ˜´ {self.nombre} estÃ¡ muy cansado para correr"

# Â¡CREANDO OBJETOS (INSTANCIAS)!
print("ğŸ• Â¡CREANDO PERROS DESDE LA CLASE! ğŸ•")

# Instancia 1
mi_perro = Perro("Max", 3, "Labrador")
print(mi_perro.ladrar())
print(mi_perro.comer("croquetas"))
print(mi_perro.correr(5))

# Instancia 2
tu_perro = Perro("Luna", 2, "Pastor AlemÃ¡n")
print(f"\n{tu_perro.ladrar()}")
print(tu_perro.comer("carne"))
print(tu_perro.correr(10))

# Â¡ACCEDIENDO A ATRIBUTOS!
print(f"\nğŸ“Š INFORMACIÃ“N DE LOS PERROS:")
print(f"ğŸ”¹ {mi_perro.nombre}: {mi_perro.edad} aÃ±os, {mi_perro.raza}")
print(f"ğŸ”¸ {tu_perro.nombre}: {tu_perro.edad} aÃ±os, {tu_perro.raza}")
print(f"ğŸ¯ Especie de ambos: {Perro.especie}")

ğŸ—ï¸ Â¡ENCAPSULAMIENTO - PROTECCIÃ“N DE DATOS!
ğŸ›¡ï¸ ATRIBUTOS PRIVADOS Y PÃšBLICOS - Â¡CONTROL TOTAL!


class CuentaBancaria:
    """Clase que demuestra encapsulamiento - Â¡Protege tus datos!"""
    
    def __init__(self, titular, saldo_inicial=0):
        # Atributos pÃºblicos
        self.titular = titular
        
        # Â¡Atributos privados (con __) - No accesibles directamente!
        self.__saldo = saldo_inicial
        self.__pin = 1234  # Muy privado
        
        # Atributo protegido (con _) - Para uso interno
        self._activa = True
        
        print(f"ğŸ¦ Cuenta creada para {self.titular}")
    
    # Â¡MÃ‰TODOS PÃšBLICOS - Interfaz controlada!
    def depositar(self, monto):
        """MÃ©todo pÃºblico para depositar"""
        if monto > 0 and self._activa:
            self.__saldo += monto
            return f"ğŸ’° DepÃ³sito exitoso: +${monto}. Saldo: ${self.__saldo}"
        return "âŒ DepÃ³sito fallido"
    
    def retirar(self, monto, pin):
        """MÃ©todo pÃºblico para retirar con validaciÃ³n"""
        if not self._verificar_pin(pin):
            return "âŒ PIN incorrecto"
        
        if monto <= 0:
            return "âŒ Monto debe ser positivo"
        
        if not self._activa:
            return "âŒ Cuenta inactiva"
        
        if self.__saldo >= monto:
            self.__saldo -= monto
            return f"ğŸ’¸ Retiro exitoso: -${monto}. Saldo: ${self.__saldo}"
        else:
            return "âŒ Fondos insuficientes"
    
    def consultar_saldo(self, pin):
        """MÃ©todo pÃºblico para consultar saldo"""
        if self._verificar_pin(pin):
            return f"ğŸ“Š Saldo actual: ${self.__saldo}"
        return "âŒ PIN incorrecto"
    
    # Â¡MÃ‰TODOS PRIVADOS - Solo uso interno!
    def _verificar_pin(self, pin):
        """MÃ©todo privado - Solo se usa dentro de la clase"""
        return pin == self.__pin
    
    def __generar_reporte(self):
        """MÃ©todo muy privado - Solo para la clase"""
        return f"Reporte interno - {self.titular}: ${self.__saldo}"
    
    # Â¡PROPIEDADES - Acceso controlado a atributos!
    @property
    def saldo(self):
        """Propiedad de solo lectura para saldo"""
        return f"Saldo disponible: ${self.__saldo}"
    
    @property
    def estado(self):
        """Propiedad para estado de la cuenta"""
        return "Activa" if self._activa else "Inactiva"
    
    @estado.setter
    def estado(self, nuevo_estado):
        """Setter para cambiar estado con validaciÃ³n"""
        if isinstance(nuevo_estado, bool):
            self._activa = nuevo_estado
            print("âœ… Estado de cuenta actualizado")
        else:
            print("âŒ Estado debe ser True o False")

# Â¡DEMOSTRACIÃ“N DE ENCAPSULAMIENTO!
print("ğŸ¦ Â¡CUENTA BANCARIA CON ENCAPSULAMIENTO! ğŸ¦")
cuenta = CuentaBancaria("Ana GarcÃ­a", 1000)

# Uso correcto a travÃ©s de mÃ©todos pÃºblicos
print(cuenta.depositar(500))
print(cuenta.retirar(200, 1234))
print(cuenta.consultar_saldo(1234))

# Â¡Intentando acceso directo a atributos privados (NO RECOMENDADO)!
print(f"\nâš ï¸ Intentando acceso directo:")
print(f"   Titular (pÃºblico): {cuenta.titular}")
# print(f"   Saldo (privado): {cuenta.__saldo}")  # Â¡ERROR! AttributeError

# Uso de propiedades
print(f"\nğŸ¯ Usando propiedades:")
print(f"   {cuenta.saldo}")
print(f"   Estado: {cuenta.estado}")

# Cambiando estado a travÃ©s del setter
cuenta.estado = False
print(f"   Nuevo estado: {cuenta.estado}")

ğŸ”„ Â¡HERENCIA - REUTILIZACIÃ“N INTELIGENTE!
ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ HERENCIA SIMPLE - Â¡EXTIENDE Y ESPECIALIZA!


# Â¡CLASE PADRE (SUPERCLASE)!
class Vehiculo:
    """Clase padre que representa un vehÃ­culo genÃ©rico"""
    
    def __init__(self, marca, modelo, aÃ±o):
        self.marca = marca
        self.modelo = modelo
        self.aÃ±o = aÃ±o
        self.velocidad = 0
        self.encendido = False
    
    def encender(self):
        """MÃ©todo de la clase padre"""
        if not self.encendido:
            self.encendido = True
            return f"ğŸ”‘ {self.marca} {self.modelo} encendido"
        return "âš ï¸ El vehÃ­culo ya estÃ¡ encendido"
    
    def apagar(self):
        """MÃ©todo de la clase padre"""
        if self.encendido and self.velocidad == 0:
            self.encendido = False
            return f"ğŸ”’ {self.marca} {self.modelo} apagado"
        return "âŒ No se puede apagar en movimiento"
    
    def acelerar(self, incremento):
        """MÃ©todo de la clase padre"""
        if self.encendido:
            self.velocidad += incremento
            return f"ğŸš— Acelerando a {self.velocidad} km/h"
        return "âŒ Enciende el vehÃ­culo primero"
    
    def info_vehiculo(self):
        """MÃ©todo que muestra informaciÃ³n"""
        return f"ğŸš— {self.marca} {self.modelo} ({self.aÃ±o}) - Velocidad: {self.velocidad} km/h"

# Â¡CLASE HIJA QUE HEREDA DE VEHICULO!
class Coche(Vehiculo):
    """Clase hija que especializa la clase Vehiculo"""
    
    def __init__(self, marca, modelo, aÃ±o, num_puertas, tipo_combustible):
        # Â¡LLAMAR AL CONSTRUCTOR DEL PADRE!
        super().__init__(marca, modelo, aÃ±o)
        
        # Â¡ATRIBUTOS ESPECÃFICOS DEL COCHE!
        self.num_puertas = num_puertas
        self.tipo_combustible = tipo_combustible
        self.aire_acondicionado = False
    
    # Â¡MÃ‰TODOS ESPECÃFICOS DEL COCHE!
    def abrir_maletero(self):
        return f"ğŸ“¦ Maletero del {self.modelo} abierto"
    
    def encender_aire(self):
        if self.encendido:
            self.aire_acondicionado = True
            return "â„ï¸ Aire acondicionado encendido"
        return "âŒ Enciende el coche primero"
    
    # Â¡SOBREESCRITURA DE MÃ‰TODOS!
    def info_vehiculo(self):
        """Sobreescribe el mÃ©todo del padre con info especÃ­fica"""
        info_base = super().info_vehiculo()
        return f"{info_base} - Puertas: {self.num_puertas} - Combustible: {self.tipo_combustible}"

# Â¡OTRA CLASE HIJA!
class Motocicleta(Vehiculo):
    """Otra clase hija especializada"""
    
    def __init__(self, marca, modelo, aÃ±o, tipo_manillar, cilindrada):
        super().__init__(marca, modelo, aÃ±o)
        self.tipo_manillar = tipo_manillar
        self.cilindrada = cilindrada
        self.casco_puesto = False
    
    def poner_casco(self):
        self.casco_puesto = True
        return "ğŸª– Casco puesto - Listo para rodar"
    
    def hacer_caballito(self):
        if self.encendido and self.casco_puesto:
            return "ğŸª Â¡Haciendo caballito con la moto!"
        return "âŒ Ponte el casco y enciende la moto primero"
    
    def info_vehiculo(self):
        info_base = super().info_vehiculo()
        return f"{info_base} - Cilindrada: {self.cilindrada}cc - Manillar: {self.tipo_manillar}"

# Â¡DEMOSTRACIÃ“N DE HERENCIA!
print("ğŸš— Â¡DEMOSTRACIÃ“N DE HERENCIA! ğŸš—")

# Creando objetos de las clases hijas
mi_coche = Coche("Toyota", "Corolla", 2023, 4, "Gasolina")
mi_moto = Motocicleta("Yamaha", "MT-07", 2022, "Deportivo", 689)

print("ğŸ”¹ COCHE:")
print(mi_coche.encender())
print(mi_coche.acelerar(50))
print(mi_coche.encender_aire())
print(mi_coche.abrir_maletero())
print(mi_coche.info_vehiculo())

print("\nğŸ”¸ MOTOCICLETA:")
print(mi_moto.encender())
print(mi_moto.poner_casco())
print(mi_moto.hacer_caballito())
print(mi_moto.acelerar(80))
print(mi_moto.info_vehiculo())

# Â¡VERIFICANDO RELACIONES!
print(f"\nğŸ” RELACIONES DE HERENCIA:")
print(f"   Â¿mi_coche es instancia de Coche? {isinstance(mi_coche, Coche)}")  # âœ…
print(f"   Â¿mi_coche es instancia de Vehiculo? {isinstance(mi_coche, Vehiculo)}")  # âœ…
print(f"   Â¿Coche es subclase de Vehiculo? {issubclass(Coche, Vehiculo)}")  # âœ…

ğŸ­ Â¡POLIMORFISMO - FLEXIBILIDAD EXTREMA!
ğŸ”€ MÃšLTIPLES FORMAS - Â¡MISMO NOMBRE, DIFERENTE COMPORTAMIENTO!


# Â¡POLIMORFISMO - DIFERENTES CLASES, MISMA INTERFAZ!
class Animal:
    """Clase base para demostrar polimorfismo"""
    
    def __init__(self, nombre):
        self.nombre = nombre
    
    def hacer_sonido(self):
        """MÃ©todo que serÃ¡ sobreescrito por las subclases"""
        raise NotImplementedError("Las subclases deben implementar este mÃ©todo")
    
    def moverse(self):
        """MÃ©todo que puede ser sobreescrito"""
        return f"{self.nombre} se estÃ¡ moviendo"

class Perro(Animal):
    def hacer_sonido(self):
        return f"ğŸ• {self.nombre} dice: Â¡Guau Guau!"
    
    def moverse(self):
        return f"ğŸ• {self.nombre} estÃ¡ corriendo alegremente"

class Gato(Animal):
    def hacer_sonido(self):
        return f"ğŸ± {self.nombre} dice: Â¡Miau Miau!"
    
    def moverse(self):
        return f"ğŸ± {self.nombre} estÃ¡ caminando sigilosamente"

class Pajaro(Animal):
    def hacer_sonido(self):
        return f"ğŸ¦ {self.nombre} dice: Â¡PÃ­o PÃ­o!"
    
    def moverse(self):
        return f"ğŸ¦ {self.nombre} estÃ¡ volando en el cielo"

class Vaca(Animal):
    def hacer_sonido(self):
        return f"ğŸ„ {self.nombre} dice: Â¡Muuu Muuu!"
    
    def moverse(self):
        return f"ğŸ„ {self.nombre} estÃ¡ caminando lentamente"

# Â¡FUNCIÃ“N POLIMÃ“RFICA!
def concierto_animales(animales):
    """FunciÃ³n que trabaja con cualquier animal - Â¡POLIMORFISMO!"""
    print("ğŸª Â¡CONCIERTO DE ANIMALES! ğŸª")
    for animal in animales:
        print(f"   {animal.hacer_sonido()}")
        print(f"   {animal.moverse()}")
        print()

# Â¡DEMOSTRACIÃ“N DEL POLIMORFISMO!
print("ğŸ­ Â¡DEMOSTRACIÃ“N DE POLIMORFISMO! ğŸ­")

# Creando diferentes animales
animales = [
    Perro("Max"),
    Gato("Luna"), 
    Pajaro("PiolÃ­n"),
    Vaca("Margarita")
]

# Â¡Misma funciÃ³n, diferentes comportamientos!
concierto_animales(animales)

# Â¡POLIMORFISMO CON MÃ‰TODOS INTEGRADOS!
print("ğŸ”§ POLIMORFISMO CON MÃ‰TODOS INTEGRADOS:")

class Libro:
    def __init__(self, titulo, autor, paginas):
        self.titulo = titulo
        self.autor = autor
        self.paginas = paginas
    
    def __str__(self):
        """MÃ©todo especial para representaciÃ³n en string"""
        return f"'{self.titulo}' por {self.autor}"
    
    def __len__(self):
        """MÃ©todo especial para la funciÃ³n len()"""
        return self.paginas
    
    def __add__(self, otro_libro):
        """MÃ©todo especial para suma (+)"""
        return f"ColecciÃ³n: {self.titulo} + {otro_libro.titulo}"

class Pelicula:
    def __init__(self, titulo, director, duracion):
        self.titulo = titulo
        self.director = director
        self.duracion = duracion
    
    def __str__(self):
        return f"'{self.titulo}' dirigida por {self.director}"
    
    def __len__(self):
        return self.duracion

# Â¡USANDO LOS MÃ‰TODOS ESPECIALES!
libro1 = Libro("Python Master", "Ana GarcÃ­a", 350)
libro2 = Libro("POO Avanzada", "Carlos LÃ³pez", 280)
pelicula = Pelicula("El Viaje Python", "MarÃ­a RodrÃ­guez", 120)

print(f"\nğŸ“š Libro: {libro1}")  # Usa __str__
print(f"   PÃ¡ginas: {len(libro1)}")  # Usa __len__

print(f"ğŸ¬ PelÃ­cula: {pelicula}")  # Usa __str__
print(f"   DuraciÃ³n: {len(pelicula)} minutos")  # Usa __len__

print(f"â• CombinaciÃ³n: {libro1 + libro2}")  # Usa __add__

âš¡ Â¡MÃ‰TODOS ESPECIALES (MAGIC METHODS) - PODER OCULTO!
ğŸ© MÃ‰TODOS MÃGICOS - Â¡SOBRECARGA DE OPERADORES!


class Vector:
    """Clase que demuestra mÃ©todos mÃ¡gicos para operaciones vectoriales"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # Â¡MÃ‰TODOS DE REPRESENTACIÃ“N!
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector(x={self.x}, y={self.y})"
    
    # Â¡MÃ‰TODOS ARITMÃ‰TICOS!
    def __add__(self, otro):
        """Sobrecarga del operador +"""
        return Vector(self.x + otro.x, self.y + otro.y)
    
    def __sub__(self, otro):
        """Sobrecarga del operador -"""
        return Vector(self.x - otro.x, self.y - otro.y)
    
    def __mul__(self, escalar):
        """Sobrecarga del operador * (multiplicaciÃ³n por escalar)"""
        return Vector(self.x * escalar, self.y * escalar)
    
    def __truediv__(self, escalar):
        """Sobrecarga del operador / (divisiÃ³n por escalar)"""
        if escalar != 0:
            return Vector(self.x / escalar, self.y / escalar)
        raise ValueError("No se puede dividir por cero")
    
    # Â¡MÃ‰TODOS DE COMPARACIÃ“N!
    def __eq__(self, otro):
        """Sobrecarga del operador =="""
        return self.x == otro.x and self.y == otro.y
    
    def __lt__(self, otro):
        """Sobrecarga del operador < (comparaciÃ³n por magnitud)"""
        return self.magnitud() < otro.magnitud()
    
    def __gt__(self, otro):
        """Sobrecarga del operador > (comparaciÃ³n por magnitud)"""
        return self.magnitud() > otro.magnitud()
    
    # Â¡MÃ‰TODOS ÃšTILES!
    def magnitud(self):
        """Calcula la magnitud del vector"""
        return (self.x**2 + self.y**2)**0.5
    
    def punto(self, otro):
        """Producto punto entre dos vectores"""
        return self.x * otro.x + self.y * otro.y
    
    # Â¡MÃ‰TODOS DE CONVERSIÃ“N!
    def __bool__(self):
        """ConversiÃ³n a booleano (False si es vector cero)"""
        return self.x != 0 or self.y != 0
    
    def __len__(self):
        """'Longitud' como magnitud entera"""
        return int(self.magnitud())

# Â¡DEMOSTRACIÃ“N DE MÃ‰TODOS MÃGICOS!
print("ğŸ© Â¡MÃ‰TODOS MÃGICOS EN ACCIÃ“N! ğŸ©")

v1 = Vector(3, 4)
v2 = Vector(1, 2)
v3 = Vector(0, 0)

print(f"ğŸ”¹ Vectores creados:")
print(f"   v1 = {v1}")
print(f"   v2 = {v2}")
print(f"   v3 = {v3}")

print(f"\nğŸ§® OPERACIONES ARITMÃ‰TICAS:")
print(f"   v1 + v2 = {v1 + v2}")
print(f"   v1 - v2 = {v1 - v2}")
print(f"   v1 * 2 = {v1 * 2}")
print(f"   v1 / 2 = {v1 / 2}")

print(f"\nğŸ” OPERACIONES DE COMPARACIÃ“N:")
print(f"   v1 == v2? {v1 == v2}")
print(f"   v1 < v2? {v1 < v2}")
print(f"   v1 > v2? {v1 > v2}")

print(f"\nğŸ“Š PROPIEDADES:")
print(f"   Magnitud de v1: {v1.magnitud():.2f}")
print(f"   Producto punto v1Â·v2: {v1.punto(v2)}")
print(f"   Â¿v1 es verdadero? {bool(v1)}")
print(f"   Â¿v3 es verdadero? {bool(v3)}")
print(f"   'Longitud' de v1: {len(v1)}")

ğŸ† Â¡SISTEMA COMPLETO DEL MUNDO REAL!
ğŸ® SISTEMA DE VIDEOJUEGO CON POO


import random

# Â¡SISTEMA DE VIDEOJUEGO CON POO AVANZADA!
class Personaje:
    """Clase base para todos los personajes del juego"""
    
    def __init__(self, nombre, nivel, vida):
        self.nombre = nombre
        self.nivel = nivel
        self.vida = vida
        self.vida_maxima = vida
        self.esta_vivo = True
    
    def atacar(self):
        """MÃ©todo base para atacar"""
        daÃ±o_base = self.nivel * 2
        return random.randint(daÃ±o_base - 2, daÃ±o_base + 2)
    
    def recibir_daÃ±o(self, daÃ±o):
        """MÃ©todo para recibir daÃ±o"""
        self.vida -= daÃ±o
        if self.vida <= 0:
            self.vida = 0
            self.esta_vivo = False
            return f"ğŸ’€ {self.nombre} ha sido derrotado!"
        return f"â¤ï¸ {self.nombre} vida restante: {self.vida}/{self.vida_maxima}"
    
    def curar(self, cantidad):
        """MÃ©todo para curarse"""
        if self.esta_vivo:
            self.vida = min(self.vida_maxima, self.vida + cantidad)
            return f"ğŸ’š {self.nombre} curado. Vida: {self.vida}/{self.vida_maxima}"
        return f"âŒ {self.nombre} no puede ser curado (estÃ¡ muerto)"
    
    def __str__(self):
        return f"{self.nombre} (Nvl {self.nivel}) - Vida: {self.vida}/{self.vida_maxima}"

class Guerrero(Personaje):
    """Clase especializada - Guerrero con alto daÃ±o fÃ­sico"""
    
    def __init__(self, nombre, nivel):
        vida_base = 100 + (nivel * 20)
        super().__init__(nombre, nivel, vida_base)
        self.fuerza = nivel * 3
    
    def atacar(self):
        """Sobreescribe el ataque con bonus de fuerza"""
        daÃ±o_base = super().atacar()
        daÃ±o_total = daÃ±o_base + self.fuerza
        return daÃ±o_total
    
    def habilidad_especial(self):
        """Habilidad Ãºnica del Guerrero"""
        if self.esta_vivo:
            daÃ±o = self.fuerza * 2
            self.vida -= 10  # Cuesta vida usar la habilidad
            return f"âš”ï¸ {self.nombre} usa 'Golpe Poderoso'! DaÃ±o: {daÃ±o}"
        return "âŒ No puede usar habilidades (estÃ¡ muerto)"

class Mago(Personaje):
    """Clase especializada - Mago con magia poderosa"""
    
    def __init__(self, nombre, nivel):
        vida_base = 60 + (nivel * 15)
        super().__init__(nombre, nivel, vida_base)
        self.mana = 100 + (nivel * 10)
        self.inteligencia = nivel * 4
    
    def atacar(self):
        """Ataque mÃ¡gico del Mago"""
        if self.mana >= 10:
            self.mana -= 10
            daÃ±o = self.inteligencia + random.randint(5, 15)
            return daÃ±o
        else:
            # Ataque fÃ­sico si no hay mana
            return super().atacar()
    
    def lanzar_hechizo(self, hechizo):
        """Habilidad Ãºnica del Mago"""
        if self.esta_vivo and self.mana >= 20:
            self.mana -= 20
            daÃ±o = self.inteligencia * 2
            return f"ğŸ”® {self.nombre} lanza '{hechizo}'! DaÃ±o: {daÃ±o} - Mana: {self.mana}"
        return "âŒ No hay suficiente mana o estÃ¡ muerto"
    
    def meditar(self):
        """Recupera mana"""
        if self.esta_vivo:
            self.mana = min(200, self.mana + 30)
            return f"ğŸ§˜ {self.nombre} medita. Mana: {self.mana}"
        return "âŒ No puede meditar (estÃ¡ muerto)"

class Arquero(Personaje):
    """Clase especializada - Arquero con ataques a distancia"""
    
    def __init__(self, nombre, nivel):
        vida_base = 80 + (nivel * 18)
        super().__init__(nombre, nivel, vida_base)
        self.agilidad = nivel * 3
        self.flechas = 20 + (nivel * 5)
    
    def atacar(self):
        """Ataque con flechas"""
        if self.flechas > 0:
            self.flechas -= 1
            daÃ±o = super().atacar() + self.agilidad
            return daÃ±o
        else:
            return 0  # Sin flechas
    
    def disparo_preciso(self):
        """Habilidad Ãºnica del Arquero"""
        if self.esta_vivo and self.flechas >= 3:
            self.flechas -= 3
            daÃ±o = (super().atacar() + self.agilidad) * 2
            return f"ğŸ¯ {self.nombre} usa 'Disparo Preciso'! DaÃ±o: {daÃ±o} - Flechas: {self.flechas}"
        return "âŒ No hay suficientes flechas o estÃ¡ muerto"
    
    def recargar_flechas(self, cantidad):
        """Recarga flechas"""
        if self.esta_vivo:
            self.flechas += cantidad
            return f"ğŸ¹ {self.nombre} recarga {cantidad} flechas. Total: {self.flechas}"
        return "âŒ No puede recargar (estÃ¡ muerto)"

# Â¡SISTEMA DE BATALLA!
def simular_batalla(jugador1, jugador2):
    """FunciÃ³n que simula una batalla entre dos personajes"""
    print(f"ğŸ® Â¡COMIENZA LA BATALLA! ğŸ®")
    print(f"âš”ï¸ {jugador1.nombre} vs {jugador2.nombre}")
    print(f"ğŸ“ {jugador1}")
    print(f"ğŸ“ {jugador2}")
    print("-" * 50)
    
    turno = 1
    while jugador1.esta_vivo and jugador2.esta_vivo and turno <= 10:
        print(f"\nğŸ”„ TURNO {turno}:")
        
        # Jugador 1 ataca a Jugador 2
        daÃ±o1 = jugador1.atacar()
        print(f"   {jugador1.nombre} ataca â†’ {jugador2.recibir_daÃ±o(daÃ±o1)}")
        
        if not jugador2.esta_vivo:
            print(f"\nğŸ‰ Â¡{jugador1.nombre} GANA LA BATALLA!")
            break
        
        # Jugador 2 ataca a Jugador 1
        daÃ±o2 = jugador2.atacar()
        print(f"   {jugador2.nombre} ataca â†’ {jugador1.recibir_daÃ±o(daÃ±o2)}")
        
        if not jugador1.esta_vivo:
            print(f"\nğŸ‰ Â¡{jugador2.nombre} GANA LA BATALLA!")
            break
        
        turno += 1
    
    if jugador1.esta_vivo and jugador2.esta_vivo:
        print(f"\nğŸ¤ Â¡EMPATE! La batalla fue muy reÃ±ida")

# Â¡DEMOSTRACIÃ“N DEL SISTEMA DE JUEGO!
print("ğŸ® Â¡SISTEMA DE VIDEOJUEGO CON POO! ğŸ®")

# Creando personajes
guerrero = Guerrero("Thor", 5)
mago = Mago("MerlÃ­n", 5)
arquero = Arquero("Legolas", 5)

# Mostrando habilidades especiales
print("âœ¨ HABILIDADES ESPECIALES:")
print(f"   {guerrero.habilidad_especial()}")
print(f"   {mago.lanzar_hechizo('Bola de Fuego')}")
print(f"   {arquero.disparo_preciso()}")

# Simulando batallas
print("\n" + "="*60)
simular_batalla(guerrero, mago)

# Recuperando personajes para otra batalla
guerrero.vida = guerrero.vida_maxima
guerrero.esta_vivo = True
arquero.vida = arquero.vida_maxima
arquero.esta_vivo = True

print("\n" + "="*60)
simular_batalla(guerrero, arquero)

ğŸŠ Â¡RESUMEN FINAL DE POO!

Â¿QUÃ‰ OBTIENES CON POO EN PYTHON?

    âœ… OrganizaciÃ³n - CÃ³digo estructurado y mantenible

    âœ… ReutilizaciÃ³n - Herencia y composiciÃ³n

    âœ… Encapsulamiento - ProtecciÃ³n de datos internos

    âœ… Polimorfismo - Flexibilidad y extensibilidad

    âœ… AbstracciÃ³n - Oculta complejidad

Â¡LOS 4 PILARES DE LA POO!

    ğŸ—ï¸ Encapsulamiento - Ocultar datos internos

    ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Herencia - Extender funcionalidad

    ğŸ­ Polimorfismo - Mismo interfaz, diferentes implementaciones

    ğŸ¯ AbstracciÃ³n - Ocultar detalles complejos

Â¡CONCEPTOS CLAVE!

    ğŸ• Clase - Molde o plantilla (class Perro:)

    ğŸ¶ Objeto - Instancia especÃ­fica (mi_perro = Perro())

    ğŸ”§ MÃ©todo - FunciÃ³n dentro de una clase (def ladrar():)

    ğŸ“Š Atributo - Variable dentro de una clase (self.nombre)

    ğŸ›¡ï¸ Atributos privados - self.__dato (no accesible externamente)

    ğŸ© MÃ©todos mÃ¡gicos - init, str, add, etc.

Â¡NO ESPERES MÃS! â°
Â¡DOMINA LA POO Y CONVIÃ‰RTETE EN ARQUITECTO DE SOFTWARE!


class MaestroPOO:
    """Â¡Clase final que demuestra todo tu poder con POO!"""
    
    def __init__(self, nombre):
        self.nombre = nombre
        self.habilidades = []
    
    def agregar_habilidad(self, habilidad):
        self.habilidades.append(habilidad)
    
    def __str__(self):
        return f"ğŸ“ {self.nombre} - Maestro de POO en Python"
    
    def mostrar_poder(self):
        print(f"\nğŸ‰ Â¡FELICIDADES {self.nombre.upper()}!")
        print("ğŸ Ahora dominas la PROGRAMACIÃ“N ORIENTADA A OBJETOS:")
        
        for i, habilidad in enumerate(self.habilidades, 1):
            print(f"   {i}. âœ… {habilidad}")
        
        return "ğŸš€ Â¡EstÃ¡s listo para crear aplicaciones empresariales!"

# Â¡CREANDO TU PODER FINAL!
tu_poder = MaestroPOO("Programador Python")
tu_poder.agregar_habilidad("Clases y Objetos")
tu_poder.agregar_habilidad("Encapsulamiento")
tu_poder.agregar_habilidad("Herencia")
tu_poder.agregar_habilidad("Polimorfismo")
tu_poder.agregar_habilidad("MÃ©todos MÃ¡gicos")
tu_poder.agregar_habilidad("Sistemas Complejos con POO")

print(tu_poder)
resultado_final = tu_poder.mostrar_poder()
print(f"\n{resultado_final}")

Â¡LA POO ES EL CORAZÃ“N DE PYTHON PROFESIONAL, Y AHORA LATIENDO EN TU CÃ“DIGO! ğŸ’“ğŸ